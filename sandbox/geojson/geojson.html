<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	 "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>

	<meta http-equiv="content-type" content="text/html;charset=utf-8">
	<script type="text/javascript" src="../build/three.min.js"></script>
<!-- JSModeler includes start -->
	<script type="text/javascript" src="../../src/core/jsm.js"></script>
	<script type="text/javascript" src="../../src/core/timer.js"></script>
	<script type="text/javascript" src="../../src/core/algorithm.js"></script>
	<script type="text/javascript" src="../../src/core/async.js"></script>
	<script type="text/javascript" src="../../src/core/check.js"></script>
	<script type="text/javascript" src="../../src/core/jsonloader.js"></script>
	<script type="text/javascript" src="../../src/geometry/definitions.js"></script>
	<script type="text/javascript" src="../../src/geometry/coord2d.js"></script>
	<script type="text/javascript" src="../../src/geometry/coord.js"></script>
	<script type="text/javascript" src="../../src/geometry/determinant.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/matrix.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystem.js"></script>
	<script type="text/javascript" src="../../src/geometry/sector.js"></script>
	<script type="text/javascript" src="../../src/geometry/line.js"></script>
	<script type="text/javascript" src="../../src/geometry/box.js"></script>
	<script type="text/javascript" src="../../src/geometry/sphere.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformation.js"></script>
	<script type="text/javascript" src="../../src/geometry/plane.js"></script>
	<script type="text/javascript" src="../../src/geometry/projection.js"></script>
	<script type="text/javascript" src="../../src/geometry/convexhull.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygon2d.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygon.js"></script>
	<script type="text/javascript" src="../../src/geometry/cutpolygon.js"></script>
	<script type="text/javascript" src="../../src/geometry/triangulation.js"></script>
	<script type="text/javascript" src="../../src/geometry/octree.js"></script>
	<script type="text/javascript" src="../../src/geometry/bsptree.js"></script>
	<script type="text/javascript" src="../../src/geometry/utilities.js"></script>
	<script type="text/javascript" src="../../src/geometry/ray.js"></script>
	<script type="text/javascript" src="../../src/modeler/color.js"></script>
	<script type="text/javascript" src="../../src/modeler/material.js"></script>
	<script type="text/javascript" src="../../src/modeler/materialset.js"></script>
	<script type="text/javascript" src="../../src/modeler/body.js"></script>
	<script type="text/javascript" src="../../src/modeler/model.js"></script>
	<script type="text/javascript" src="../../src/modeler/adjacencyinfo.js"></script>
	<script type="text/javascript" src="../../src/modeler/bodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/textureutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/cututils.js"></script>
	<script type="text/javascript" src="../../src/modeler/generator.js"></script>
	<script type="text/javascript" src="../../src/modeler/camera.js"></script>
	<script type="text/javascript" src="../../src/modeler/explode.js"></script>
	<script type="text/javascript" src="../../src/modeler/exporter.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebody.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglemodel.js"></script>
	<script type="text/javascript" src="../../src/modeler/converter.js"></script>
	<script type="text/javascript" src="../../src/modeler/rayutils.js"></script>
	<script type="text/javascript" src="../../src/import/binaryreader.js"></script>
	<script type="text/javascript" src="../../src/import/importer.js"></script>
	<script type="text/javascript" src="../../src/import/importer3ds.js"></script>
	<script type="text/javascript" src="../../src/import/importerobj.js"></script>
	<script type="text/javascript" src="../../src/import/importerstl.js"></script>
	<script type="text/javascript" src="../../src/import/importercommon.js"></script>
	<script type="text/javascript" src="../../src/renderer/webglutils.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderlight.js"></script>
	<script type="text/javascript" src="../../src/renderer/rendermaterial.js"></script>
	<script type="text/javascript" src="../../src/renderer/rendermesh.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderbody.js"></script>
	<script type="text/javascript" src="../../src/renderer/shaderprogram.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/pointcloudrenderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderconverter.js"></script>
	<script type="text/javascript" src="../../src/viewer/mouse.js"></script>
	<script type="text/javascript" src="../../src/viewer/touch.js"></script>
	<script type="text/javascript" src="../../src/viewer/painter.js"></script>
	<script type="text/javascript" src="../../src/viewer/drawing.js"></script>
	<script type="text/javascript" src="../../src/viewer/navigation.js"></script>
	<script type="text/javascript" src="../../src/viewer/softwareviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/spriteviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/viewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/pointcloudviewer.js"></script>
	<script type="text/javascript" src="../../src/extras/solidgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/extgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/subdivision.js"></script>
	<script type="text/javascript" src="../../src/extras/csg.js"></script>
	<script type="text/javascript" src="../../src/extras/curves.js"></script>
	<script type="text/javascript" src="../../src/extensions/svgtomodel/svgtomodel.js"></script>
	<script type="text/javascript" src="../../src/extensions/threeviewer/threeconverter.js"></script>
	<script type="text/javascript" src="../../src/extensions/threeviewer/threeviewer.js"></script>
<!-- JSModeler includes end -->
	<script type="text/javascript" src="../utils/hashchanger.js"></script>
	<title>Example</title>
	
	<style>
		html, body
		{
			margin : 0px;
			padding : 0px;
		}
		
		canvas
		{
			display : block;
		}
	</style>

	<script type="text/javascript">
		JSM.ModelWithMaterials = function ()
		{
			this.model = new JSM.Model ();
			this.materials = new JSM.Materials ();
		}
		
		JSM.ConvertGeoJsonToModel = function (geoJson, sphereRadius, polygonThickness)
		{
			function ConvertCoordinate (sphereRadius, coordinate)
			{
				var sphereOffset = sphereRadius * 0.005;
				var lon = coordinate.x * JSM.DegRad;
				var lat = (90.0 - coordinate.y) * JSM.DegRad;
				return JSM.SphericalToCartesian (sphereRadius + sphereOffset, lat, lon);
			}

			function GetSegmentCount (distance)
			{
				var segmentCount = parseInt (distance / 5.0, 10);
				if (segmentCount === 0) {
					segmentCount = 1;
				}
				return segmentCount;
			}
			
			function GetSegmentCountBetweenCoords (begCoordinate, endCoordinate)
			{
				var distance = begCoordinate.DistanceTo (endCoordinate);
				return GetSegmentCount (distance);
			}
			
			function AddPointToBody (body, sphereRadius, sphereCoord, materialIndex)
			{
				var cartesianCoord = ConvertCoordinate (sphereRadius, sphereCoord);
				var vertexIndex = JSM.AddVertexToBody (body, cartesianCoord.x, cartesianCoord.y, cartesianCoord.z);
				var pointIndex = JSM.AddPointToBody (body, vertexIndex);
				var bodyPoint = body.GetPoint (pointIndex);
				bodyPoint.SetMaterialIndex (materialIndex);
			}
		
			function AddLineToBody (body, sphereRadius, begSphereCoord, endSphereCoord, materialIndex)
			{
				var sector = new JSM.Sector2D (begSphereCoord, endSphereCoord);
				var segmentCount = GetSegmentCountBetweenCoords (begSphereCoord, endSphereCoord);
				var segmentedCoords = JSM.GetSectorSegmentation2D (sector, segmentCount);
				var lastLine = body.LineCount ();
				var i, cartesianCoord, vertexIndex;
				for (i = 0; i < segmentedCoords.length; i++) {
					cartesianCoord = ConvertCoordinate (sphereRadius, segmentedCoords[i]);
					vertexIndex = JSM.AddVertexToBody (body, cartesianCoord.x, cartesianCoord.y, cartesianCoord.z);
					if (i > 0) {
						JSM.AddLineToBody (body, vertexIndex - 1, vertexIndex);
					}
				}
				var bodyLine;
				for (i = lastLine; i < body.LineCount (); i++) {
					bodyLine = body.GetLine (i);
					bodyLine.SetMaterialIndex (materialIndex);
				}				
			}

			function AddPolygonToBody (body, sphereRadius, polygonThickness, polygon, materialIndex)
			{
				function AddSegmentedPolygonToBody (body, polygon, sphereRadius, polygonThickness)
				{
					function AddMainPolygon (body, vertexCoords, reversed)
					{
						var vertices = [];
						var i, vertexCoord;
						for (i = 0; i < vertexCoords.length; i++) {
							vertexCoord = vertexCoords[i];
							vertices.push (JSM.AddVertexToBody (body, vertexCoord.x, vertexCoord.y, vertexCoord.z));
						}
						if (reversed) {
							var reversedVertices = vertices.slice (0);
							reversedVertices.reverse ();
							JSM.AddPolygonToBody (body, reversedVertices);
						} else {
							JSM.AddPolygonToBody (body, vertices);
						}
						return vertices;
					}
					
					function AddSidePolygons (body, topVertices, bottomVertices)
					{
						var vertexCount = topVertices.length;
						var i, curr, next, bottom, nbottom;
						for (i = 0; i < vertexCount; i++) {
							curr = topVertices[i];
							next = topVertices[JSM.NextIndex (i, vertexCount)];
							bottom = bottomVertices[i];
							nbottom = bottomVertices[JSM.NextIndex (i, vertexCount)];
							JSM.AddPolygonToBody (body, [curr, next, nbottom, bottom]);
						}
					}
				
					var eps = 0.001;
					var vertexCoordsTop = [];
					var vertexCoordsBottom = [];
					var i, polygonVertex, cartesianCoord;
					for (i = 0; i < polygon.VertexCount (); i++) {
						polygonVertex = polygon.GetVertex (i);
						cartesianCoord = ConvertCoordinate (sphereRadius, polygonVertex);
						if (vertexCoordsTop.length > 0) {
							if (vertexCoordsTop[vertexCoordsTop.length - 1].IsEqualWithEps (cartesianCoord, eps)) {
								continue;
							}
							if (i == polygon.VertexCount () - 1) {
								if (vertexCoordsTop[0].IsEqualWithEps (cartesianCoord, eps)) {
									continue;
								}
							}
						}
						vertexCoordsTop.push (cartesianCoord);
						if (!JSM.IsZero (polygonThickness)) {
							vertexCoordsBottom.push (ConvertCoordinate (sphereRadius - polygonThickness, polygonVertex));
						}
					}
					if (vertexCoordsTop.length >= 3) {
						var topVertices = AddMainPolygon (body, vertexCoordsTop, true);
						if (vertexCoordsBottom.length !== 0) {
							var bottomVertices = AddMainPolygon (body, vertexCoordsBottom, false);
							AddSidePolygons (body, topVertices, bottomVertices);
						}
					}				
				}
			
				var box = polygon.GetBoundingBox ();
				var xSegments = GetSegmentCount (box.max.x - box.min.x);
				var ySegments = GetSegmentCount (box.max.y - box.min.y);
				var segmentedPolygons = JSM.SegmentPolygon2D (polygon, xSegments, ySegments);
				var i;
				for (i = 0; i < segmentedPolygons.length; i++) {
					AddSegmentedPolygonToBody (body, segmentedPolygons[i], sphereRadius, polygonThickness);
				}
				body.SetPolygonsMaterialIndex (materialIndex);
			}

			function AddPoint (sphereRadius, coordinate, materialIndex)
			{
				if (pointsBody === null) {
					pointsBody = new JSM.Body ();
					result.model.AddBody (pointsBody);
				}
				var sphereCoord = JSM.CoordFromArray2D (coordinate);
				AddPointToBody (pointsBody, sphereRadius, sphereCoord, materialIndex);
			}
			
			function AddLine (sphereRadius, coordinates, materialIndex)
			{
				if (linesBody === null) {
					linesBody = new JSM.Body ();
					result.model.AddBody (linesBody);
				}

				var begSphereCoord = JSM.CoordFromArray2D (coordinates[0]);
				var endSphereCoord = JSM.CoordFromArray2D (coordinates[1]);
				AddLineToBody (linesBody, sphereRadius, begSphereCoord, endSphereCoord, materialIndex);
			}
			
			function AddPolygon (sphereRadius, polygonThickness, coordinates, materialIndex)
			{
				var body = new JSM.Body ();
				result.model.AddBody (body);
				
				var contourPolygon = new JSM.ContourPolygon2D ();
				var i, j, currentContour, sphereCoord;
				for (i = 0; i < coordinates.length; i++) {
					contourPolygon.AddContour ();
					currentContour = coordinates[i];
					for (j = 0; j < currentContour.length - 1; j++) {
						sphereCoord = JSM.CoordFromArray2D (currentContour[j]);
						contourPolygon.AddVertexCoord (sphereCoord);
					}
				}

				if (contourPolygon.GetOrientation () != JSM.Orientation.Clockwise) {
					contourPolygon.ReverseVertices ();
				}
				var polygon = JSM.ConvertContourPolygonToPolygon2D (contourPolygon);
				AddPolygonToBody (body, sphereRadius, polygonThickness, polygon, materialIndex);	
			}

			function AddMultiPolygon (sphereRadius, polygonThickness, coordinates, materialIndex)
			{
				var i;
				for (i = 0; i < coordinates.length; i++) {
					AddPolygon (sphereRadius, polygonThickness, coordinates[i], materialIndex);
				}
			}	

			function AddFeature (sphereRadius, polygonThickness, feature)
			{
				if (!feature.type || feature.type != 'Feature') {
					return false;
				}
				
				if (!feature.geometry || !feature.geometry.type || !feature.geometry.coordinates) {
					return false;
				}
				
				var materialColor = JSM.RandomInt (0, 16777215);
				var material = new JSM.Material ({ambient : materialColor, diffuse : materialColor, singleSided : true});
				var materialIndex = result.materials.AddMaterial (material);
				if (feature.geometry.type == 'Point') {
					material.pointSize = 10;
					AddPoint (sphereRadius, feature.geometry.coordinates, materialIndex);
				} else if (feature.geometry.type == 'LineString') {
					AddLine (sphereRadius, feature.geometry.coordinates, materialIndex);
				} else if (feature.geometry.type == 'Polygon') {
					AddPolygon (sphereRadius, polygonThickness, feature.geometry.coordinates, materialIndex);
				} else if (feature.geometry.type == 'MultiPolygon') {
					AddMultiPolygon (sphereRadius, polygonThickness, feature.geometry.coordinates, materialIndex);
				}
			}
		
			if (!geoJson.type || geoJson.type != 'FeatureCollection') {
				return null;
			}
			
			if (!geoJson.features) {
				return null;
			}
			
			var result = new JSM.ModelWithMaterials ();
			var pointsBody = null;
			var linesBody = null;
			
			var i, feature;
			for (i = 0; i < geoJson.features.length; i++) {
				feature = geoJson.features[i];
				AddFeature (sphereRadius, polygonThickness, feature);
			}
			return result;
		}
		
		function AddEarth (sphereRadius, viewer)
		{
			var body = new JSM.GenerateSphere (sphereRadius, 20);
			body = JSM.GenerateWireBody (body);
			
			var materials = new JSM.Materials ();
			materials.AddMaterial (new JSM.Material ({ambient : 0xdddddd, diffuse : 0xdddddd}));
			body.SetLinesMaterialIndex (0);

			viewer.AddBody (JSM.ConvertBodyToRenderBody (body, materials));		
		}
		
		function RenderCurrentGeoJson (viewer, index)
		{
			viewer.RemoveBodies ();	
			viewer.Draw ();
			
			var jsonFiles = [
				'points.json',
				'lines.json',
				'rectangles.json',
				'holes.json',
				'hungary.json',
				'world.json'
			];
			if (index < 0 || index >= jsonFiles.length) {
				return;
			}
			
			var sphereRadius = 100.0;
			var polygonThickness = 1.0;
			AddEarth (sphereRadius, viewer);
			JSM.LoadJsonFile (jsonFiles[index], function (jsonData) {
				var model = JSM.ConvertGeoJsonToModel (jsonData, sphereRadius, polygonThickness);
				var renderBodies = JSM.ConvertModelToRenderBodies (model.model, model.materials);
				viewer.AddBodies (renderBodies);
				viewer.Draw ();
			});
		}
	
		function Load ()
		{
			var camera = new JSM.Camera (
				new JSM.Coord (200.0, -200.0, 200.0),
				new JSM.Coord (0.0, 0.0, 0.0),
				new JSM.Vector (0.0, 0.0, 1.0),
				45.0,
				1.0,
				10000.0
			);
			
			var viewer = new JSM.Viewer ();
			var canvas = document.getElementById ('example');
			if (!viewer.Init (canvas, camera)) {
				alert ('error');
			}
			
			viewer.SetFullscreen (true);
			var hashChanger = new HashChanger ();
			hashChanger.Init (function () {
				var index = hashChanger.GetHashIndex ();
				RenderCurrentGeoJson (viewer, index);
			});
		}
	
	    window.onload = function ()
		{
			Load ();
		}
	</script>

</head>

<body>
	<canvas id="example" width="800" height="500"></canvas>
</body>

</html>
